\documentclass[12pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{proof}
\usepackage[margin=1in]{geometry}
\usepackage{braket}

\usepackage[square]{natbib}
%\usepackage[parfill]{parskip}
\author{David Thibodeau \and Jason Wiener}
\title{COMP 512: Deliverable 2}
\date{\today}

%Declare formatting for theorems, definitions, etc.
\theoremstyle{plain}% default 
\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma} 
\newtheorem{prop}[thm]{Proposition} 
\newtheorem*{cor}{Corollary} 

\theoremstyle{definition} 
\newtheorem{defn}{Definition}[section] 
\newtheorem{conj}{Conjecture}[section] 
\newtheorem{exmp}{Example}[section]
\newtheorem{exer}{Exercise}

\theoremstyle{remark} 
\newtheorem*{rem}{Remark} 
\newtheorem*{note}{Note} 
\newtheorem{case}{Case}

\usepackage{srcltx}
\usepackage{listings}
\lstloadlanguages{Java}
\lstset{language=Java}

\newcommand{\veps}{\varepsilon}
\newcommand{\ra}{\rightarrow}
\newcommand{\da}{\Downarrow}
\newcommand{\mips}{{\ensuremath{\text{MIP}^*}} }
\newcommand{\mipns}{{\ensuremath{\text{MIP}^{\text{ns}}}} }
\newcommand{\z}{\mathbb{Z}}

%
% --------------------------------------------------------------------------- 
%
% Set up listings "literate" keyword stuff (for \lstset below)
%
\newdimen\zzlistingsize
\newdimen\zzlistingsizedefault
 \zzlistingsizedefault=11pt
% \zzlistingsizedefault=10pt
%\zzlistingsizedefault=11pt
\zzlistingsize=\zzlistingsizedefault
\global\def\InsideComment{0}
\newcommand{\Lstbasicstyle}{\fontsize{\zzlistingsize}{1.05\zzlistingsize}\ttfamily}
\newcommand{\keywordFmt}{\fontsize{1.0\zzlistingsize}{1.0\zzlistingsize}\bf}
\newcommand{\smartkeywordFmt}{\if0\InsideComment\keywordFmt\fi}
\newcommand{\commentFmt}{\def\InsideComment{1}\fontsize{0.95\zzlistingsize}{1.0\zzlistingsize}\rmfamily\slshape}

\newcommand{\LST}{\setlistingsize{\zzlistingsizedefault}}

\newlength{\zzlstwidth}
\newcommand{\setlistingsize}[1]{\zzlistingsize=#1%
\settowidth{\zzlstwidth}{{\Lstbasicstyle~}}}
\setlistingsize{\zzlistingsizedefault}
\lstset{literate={->}{{$\rightarrow~$}}2 %
                               {â†’}{{$\rightarrow~$}}2 %
                               {=>}{{$\Rightarrow~$}}2 %
                               {id}{{{\smartkeywordFmt id}}}1 % 3 $~$
                               {\\}{{$\lambda$}}1 %
                               {\\n}{$\backslash n$}1 %
                               {\\Pi}{{$\Pi$}}1 %
                               {\\psi}{{$\psi$}}1 %
                               {\\gamma}{{$\gamma$}}1 %
                               {FN}{{$\Lambda$}}1 %
                               {<<}{\color{mydblue}}1 %
                               {<<r}{\color{dGreen}}1 %
                               {<*}{\color{dRed}}1 %
                               {<dim}{\color{dimgrey}}1 %
                               {>>}{\color{black}}1 %
                               {>>b}{\color{mydblue}}1 %
                               {phi}{$\phi$}1 %
                               {psi}{$\psi$}1 %
                              % {..}{$\dots$}1 %
               ,
               columns=[l]fullflexible,
               basewidth=\zzlstwidth,
               basicstyle=\Lstbasicstyle,
               keywordstyle=\keywordFmt,
               identifierstyle=\relax,
%               stringstyle=\relax,
               commentstyle=\commentFmt,
               breaklines=true,
               breakatwhitespace=true,   % doesn't do anything (?!)
               mathescape=true,   % interprets $...$ in listing as math mode
%               tabsize=8,
               texcl=false}

\newcommand{\java}[1]{{\lstinline!#1!}} 

\newenvironment{figureone}[1]{%
  \def\deffigurecaption{#1}%
  \begin{figure}[htbp]%
  \begin{center}%
  %\begin{scriptsize}%
  \begin{minipage}{\columnwidth}%
  \hrule \vspace*{2ex}%
%   % reassign dimensions for prooftrees
%   \proofrulebaseline=2ex%
%   \proofrulebreadth=.05em%
%   \proofdotseparation=1.25ex%
}{%
%\vspace{2ex} \hrule% 
%\addvspace{2ex}%
  \end{minipage}%
  %\end{scriptsize}%
  \end{center}%
  \caption{\deffigurecaption}%
  \end{figure}%
}

\begin{document}
\maketitle

Our work for this deliverable extends our RMI implementation from the previous deliverable. We added to it a lock manager and a transaction manager, both of which handle the correct execution of transaction based writes and read in 2PL with a one-phase commit. Our work for this deliverable extends our RMI implementation from the previous deliverable. Both the transaction manager and the lock manager appear as objects of the middleware which uses them to handle transactions.

\subsection*{Lock Manager}

The lock manager follows mostly the provided code. It indexes locks it gives to objects in two ways: the object that is being locked and the transaction holding the lock. It has a waiting list for the transactions that want a lock and it will raise a deadlock exception if a given delay is passed. We extended the lock manager to handle the upgrade of locks from read lock to write lock.

\subsection*{Transaction Manager}

The transaction manager handles the transactions. The class contains an inner class \java{Transaction} which contains all the information about a particular one. It is defined as an inner class to give access to abort method from the transaction manager. The reason for this requirement is explained in the Time To Live mechanism (TTL) subsection. 

A transaction object contains the transaction ID, together with a boolean for each of the RMs telling us whether or not the transaction involve this RM. It also contains the TTL presented below.

The transaction manager stores all transactions in an hashtable using the transaction ID as key. It also keeps the RMI objects for each RM obtained from the Middleware when the transaction manager is created. The RMIs are used to coordinate with them to commit/abort/shutdown.

It creates a new transaction object when its \java{start} method is called, giving it a new unique ID that is sent back to the Middleware, then to the client. It can commit and abort transactions with the corresponding methods. Those methods will simply remove the transaction object from the hashtable and call the commit or abort method, respectively, from the enlisted RMs to have them discard or register the writes they kept in store.

\subsubsection*{Time To Live Mechanism}

The transaction manager handles a (TTL) which is used to abort inactive transactions from crashed or idle clients. It is defined as an inner class within the Transaction class and contains a timer and an extension of the class \java{TimerTask}. On tick, the timer task will run and abort the transaction, giving up all the locks the transactions held. 

Each time an operation involves this transaction, the \java{lives} method from the transaction manager will retreive the transaction and call its \java{resetTTL} method. This method will cancel the current timer, preventing it from start the scheduled task, and create another one, rescheduling the task.

The inactivity delay is defined by the constant life. The current implementation sets it to 10 minutes (600 seconds) but it can easily be modified.

\begin{figureone}{\java{TimeToLive} class in TMimpl.java \label{fig:ttl}}
\begin{lstlisting}
class TimeToLive {

  private Timer timer;
  private final long life = 600; //in seconds; 10 min.
  
  TimeToLive() {
    timer = new Timer();
    timer.schedule(new RemindTask(), life*1000);
  }
  
  class RemindTask extends TimerTask {
    public void run() {
      try {
	synchronized(lock){
	  lock.UnlockAll(id);
	}
	abort(id);
      } catch (Exception e) {
	// Should not happen
	e.printStackTrace();
      }
      timer.cancel(); //Terminate the timer thread
    }
  }	
  
  void reset(){
    timer.cancel();
    timer = new Timer();
    timer.schedule(new RemindTask(), life*1000);
  }
}
\end{lstlisting}
\end{figureone}


\subsection*{Coordination from the Middleware}

The middleware, as before, acts as coordinator between the client and the resources managers. It receives the queries from the clients and will use the lock manager to give locks for the given transactions. Figure~\ref{fig:operation} shows the \java{deleteCars} method and illustrates the coordination done by the middleware. If the locks can be given, it will tell the RMs to do the given operations. 

The obtenion of the lock is done through the method \java{acquireLock} which is presented in figure~\ref{fig:acquireLock}. This method will tell the transaction manager that the transaction is still alive (resetting its TTL timer), then will verify if a lock can be given. If the lock can be given, and it is a write lock, it will tell the transaction manager to enlist the corresponding RM. If it cannot obtain the lock, a \java{DeadlockException} will be raised and it will then abort the whole transaction by raising \java{TransactionAbortedException}. The method returns a boolean obtained from \java{tm.lives} indicating whether or not the operation is done for a transaction in autocommitted mode. This mode is described in a subsection below.

\begin{figureone}{\java{acquireLock} method in Middleware.java \label{fig:acquireLock}}
\begin{lstlisting}
private boolean acquireLock(int id, RMType type, String key, int lockType) 
    throws TransactionAbortedException, InvalidTransactionException {
  try {
    boolean b = tm.lives(id);
    boolean locked = false;
    synchronized(lock){
      locked = lock.Lock(id, key, lockType);
    }
    if (locked) {
      if(lockType == LockManager.WRITE)
      tm.enlist(id, type);
      return b;
    } else{
      throw new InvalidTransactionException();
    }
  } catch (DeadlockException e) {
    throw new TransactionAbortedException(id);
  }
}
\end{lstlisting}
\end{figureone}

The middleware also receives the start/commit/abort requests from the client. For the start operation, it simply forwards the query to the transaction manager, gettin from it a transaction ID that is sent back to the client. During commit/abort operations, it simply unlocks all the locks held by the transaction, then passes control to the transaction manager to handle the rest of the commit/abort.

\subsubsection*{Shutting Down the Server}

The server can go in shutdown mode if a client uses the shutdown command. The middleware will set the \java{shutdown} flag to true, preventing any new operation to be executed. Then, it will pass the control to the transaction manager which will wait for all the existing threads from the Middleware server to finish to abort all remaining transactions. It will then tell the RMs to shutdown. The RMs will simply send an exit signal since there is no opened transactions and the system does not yet implement recovery mechanisms. The operations done by the transaction manager appears in figure~\ref{fig:shutdown}.

\begin{figureone}{\java{shutdown} method in TMimpl.java \label{fig:shutdown}}
\begin{lstlisting}
public boolean shutdown() throws RemoteException {
  Set<Thread> threadSet = Thread.getAllStackTraces().keySet();
  for (Thread s : threadSet) {
    try {
      s.join();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
  for(Enumeration<Transaction> i = transactionHT.elements(); i.hasMoreElements(); ){
    Transaction tr = i.nextElement();
    try {
      abort(tr.getID());
    } catch (Exception e) {
      // Should not happen
      e.printStackTrace();
    }
  }
  rmCar.shutdown();
  rmFlight.shutdown();
  rmHotel.shutdown();
  rmCustomer.shutdown();
  return true;
}
\end{lstlisting}
\end{figureone}

\subsubsection*{Autocommitting Transactions}

The server implements an autocommitting mechanism. A client can use the autocommit command to obtain a transaction ID that will perform autocommitting transactions, that is, each query will form its own transaction. It will obtain the necessary locks, perform the operations, then the middleware will ask the transaction manager to commit those changes and will release the locks. 

This autocommit feature appears as a flag in the transaction object. Such object does not have a TTL timer since they are noone possibly waiting for this transaction to finish. Moreover, committing or aborting any of its transactions will not remove the transaction object and so the ID can be used to do any number of autocommitting operations.  


\begin{figureone}{\java{deleteCars} method in Middleware.java \label{fig:operation}}
\begin{lstlisting}
public boolean deleteCars(int id, String location)
    throws RemoteException, InvalidTransactionException, TransactionAbortedException, ServerShutdownException {
  try{
    if(shutdown)
      throw new ServerShutdownException();
    boolean b = acquireLock(id, RMType.CAR, Car.getKey(location), LockManager.WRITE);
    boolean b1 = rmCar.deleteCars(id, location);
    if(!b)
      commit(id);
    return b1;
  } catch (TransactionAbortedException i) {
    abort(id);
    throw new TransactionAbortedException(id);
  }
}
\end{lstlisting}
\end{figureone}


\subsection*{Transactions from the RMs' Point of View}




\end{document}
